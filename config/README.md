

порядок запуска сервисов

первым надо запускать config
вторым - eureka
конфиг и еврика имеют циклическую зависимость друг от друга, по этому, при старте конфига будет ошибка о недоступности еврики.
но это ничего, так как, когда еврика поднимется, конфиг обновит в ней свою регистрацию.
последующие сервисы будут получать в еврике адрес и порт конфиг сервера, читать на нем свою конфигурацию ( свой порт ),
стартовать и регистрировать себя в еврике.
третьим - auth
важно, чтобы сервис auth был бы зарегистрирован в eureka на момент старта сервисов, 
которые его динамически находят в коде - exchange, exgen



логика работы блока наличных cash

счет account создается при внесении на него наличных денег.
счет не удаляется. 
если на счету 0, с него нельзя снять деньги, будет ошибка.
если счета нет, с него нельзя снять деньги, будет ошибка.
при попытке снять больше денег, чем есть на счету, выдается всё, что есть и баланс счета становится 0.
это удобно для тестов на удаление пользователя.


безопасность

безопасность пользователей

логика работы
при введении логина-пароля в форме, мс front оправляет запрос с username, password  в мс auth
мс auth передает этот запрос в мс accounts, где происходит сравнение с сохраненным хешем пароля, и если ок, 
то мс accounts возвращает в мс auth userId, -1 в случае ошибки
мс auth в случае успешного ответа из accounts генерирует JWT token в который добавляет username и userId
мс front сохраняет полученный токен в куки jwt_token.
в мс front настроен SecurityConfig:
сначала срабатывает jwtAuthenticationFilter, который отправляет в мс auth запрос на валидацию токена,
а затем срабатывает authorizeHttpRequests так, чтобы при обращении по путям, содержащим id пользователя,
вызывалась бы проверка, метод authorizeHttpRequests, 
который сравнивает запрашиваемый в пути userId с userId, хранящемся в токене

в сервисе accounts так же поднят SecurityConfig, который делает те же проверки - сравнивает userId в токене
c userId в запрашиваемом пути. для этого сервис front отправляет токен в заголовке ( требует использования restTemplate.exchange)
так же для запросов которые идут по цепочке front -> cash -> accounts  and  front->transfer->accounts 
сервисы cash и accounts читают токен пришедший от фронта и передают его без проверок в accounts

безопасность микросервисов

я уже больше месяца пишу это задание двухнедельного спринта и не получаю никакой обратной связи, я даже не уверен, 
что двигаюсь в правильном направлении. 
для демонстрации авторизации сервисов через OAuth2 были выбраны 2 сервиса exchange и exgen.
сервис exchange имеет два эндпоинта, один для чтения курсов валют, он незащищен, второй для записи, 
он защищен, нужен токен и проверяется scope=write.
для этого на сервисе auth был сделан самописный OAuth2 сервер. я там кстати так и не понял, правда ли, что надо самому
вручную создавать таблицы, в которые потом Спринг сам пишет. просто спринг сам всё автоматически делает, даже репозиторий 
сам создает, но вот уговорить его автосоздать таблицы не получилось.



Dynamic Discovery

конфиги всех сервисов хранятся в репозитории мс config, все, кроме самого конфиг.
все сервисы зарегистрированы в service discovery ms eureka, все, кроме самой эврики.
получается, конфиг и эврика циклически связаны, но это ничего, так как конфиг продолжит загрузку даже не найдя эврики, 
а позже в ней зарегистрируется.
всем сервисам порты назначаются в конфиг.
везде использован формат applicatoin.properties, так как для меня он гораздо более читаем, чем yaml.
в эврике можно получить ip address and port микросервиса. 
все сервисы используют конфиг класс RestTemplateConfig с аннотацией @LoadBalanced, 
что позволяет делать рест запросы, используя имена сервисов. 
все обращения сервисов друг к другу делаются через гейтвей, 
запросы имеют вид http://gateway/<имя микросервиса>/<путь на сервисе>
например  "http://gateway/accounts/api/users/{id}/password?newPassword={password}"



базы данных

имеются у auth, accounts, notify
это H2 базы в файле
они лежат в домашней директории ~/IdeaProjects/javamid-bank/data
можно переопределить 
VM options: -DDB_PATH=./data
Environment variable: DB_PATH=./data

