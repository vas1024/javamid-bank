

порядок запуска сервисов

первым надо запускать config
вторым - eureka
конфиг и еврика имеют циклическую зависимость друг от друга, по этому, при старте конфига будет ошибка о недоступности еврики.
но это ничего, так как, когда еврика поднимется, конфиг обновит в ней свою регистрацию.
последующие сервисы будут получать в еврике адрес и порт конфиг сервера, читать на нем свою конфигурацию ( свой порт ),
стартовать и регистрировать себя в еврике.
третьим - gateway
четвертым - auth
важно, чтобы сервис auth был бы зарегистрирован в eureka на момент старта сервисов, 
которые его динамически находят в коде - exchange, exgen



логика работы блока наличных cash

счет account создается при внесении на него наличных денег.
счет не удаляется. 
если на счету 0, с него нельзя снять деньги, будет ошибка.
если счета нет, с него нельзя снять деньги, будет ошибка.
при попытке снять больше денег, чем есть на счету, выдается всё, что есть и баланс счета становится 0.
это удобно для тестов на удаление пользователя.


безопасность

безопасность пользователей

логика работы
при введении логина-пароля в форме, мс front оправляет запрос с username, password  в мс auth
мс auth передает этот запрос в мс accounts, где происходит сравнение с сохраненным хешем пароля, и если ок, 
то мс accounts возвращает в мс auth userId, -1 в случае ошибки
мс auth в случае успешного ответа из accounts генерирует JWT token в который добавляет username и userId
мс front сохраняет полученный токен в куки jwt_token.
в мс front настроен SecurityConfig:
сначала срабатывает jwtAuthenticationFilter, который отправляет в мс auth запрос на валидацию токена,
а затем срабатывает authorizeHttpRequests так, чтобы при обращении по путям, содержащим id пользователя,
вызывалась бы проверка, метод authorizeHttpRequests, 
который сравнивает запрашиваемый в пути userId с userId, хранящемся в токене

в сервисе accounts так же поднят SecurityConfig, который делает те же проверки - сравнивает userId в токене
c userId в запрашиваемом пути. для этого сервис front отправляет токен в заголовке ( требует использования restTemplate.exchange)
так же для запросов которые идут по цепочке front -> cash -> accounts  and  front->transfer->accounts 
сервисы cash и accounts читают токен пришедший от фронта и передают его без проверок в accounts

безопасность микросервисов

я уже больше месяца пишу это задание двухнедельного спринта и не получаю никакой обратной связи, я даже не уверен, 
что двигаюсь в правильном направлении. 
для демонстрации авторизации сервисов через OAuth2 были выбраны 2 сервиса exchange и exgen.
сервис exchange имеет два эндпоинта, один для чтения курсов валют, он незащищен, второй для записи, 
он защищен, нужен токен и проверяется scope=write.
для этого на сервисе auth был сделан самописный OAuth2 сервер. я там кстати так и не понял, правда ли, что надо самому
вручную создавать таблицы, в которые потом Спринг сам пишет. просто спринг сам всё автоматически делает, даже репозиторий 
сам создает, но вот уговорить его автосоздать таблицы не получилось.



Dynamic Discovery

конфиги всех сервисов хранятся в репозитории мс config, все, кроме самого конфиг.
все сервисы зарегистрированы в service discovery ms eureka, все, кроме самой эврики.
получается, конфиг и эврика циклически связаны, но это ничего, так как конфиг продолжит загрузку даже не найдя эврики, 
а позже в ней зарегистрируется.
всем сервисам порты назначаются в конфиг.
везде использован формат applicatoin.properties, так как для меня он гораздо более читаем, чем yaml.
в эврике можно получить ip address and port микросервиса. 
все сервисы используют конфиг класс RestTemplateConfig с аннотацией @LoadBalanced, 
что позволяет делать рест запросы, используя имена сервисов. 
все обращения сервисов друг к другу делаются через гейтвей, 
запросы имеют вид http://gateway/<имя микросервиса>/<путь на сервисе>
например  "http://gateway/accounts/api/users/{id}/password?newPassword={password}"

в докере микросервисам надо первоначально найти сервер с eurika. для этого используется докер dns и свойство спринга подставлять 
environment variable в файлы application.properties: 
deureka.client.serviceUrl.defaultZone=${EUREKA_URL:http://localhost:8761/eureka}
и для каждого мс надо определить EUREKA_URL=http://eureka:8761/eureka в докер-композ



базы данных

имеются у auth, accounts, notify
это H2 базы в файле
они лежат в домашней директории ~/IdeaProjects/javamid-bank/data
можно переопределить 
VM options: -DDB_PATH=./data
Environment variable: DB_PATH=./data


сборка докера

в каждом модуле есть свой Dockerfile с правильным портом для микросервиса.
надо зпустить построение джарников
mvn clean package -DskipTests
затем из корня проекта запустить
docker build -t bank/accounts:1.0.0 ./accounts
docker build -t bank/auth:1.0.0 ./auth
docker build -t bank/blocker:1.0.0 ./blocker
docker build -t bank/cash:1.0.0 ./cash
docker build -t bank/config:1.0.0 ./config
docker build -t bank/eureka:1.0.0 ./eureka
docker build -t bank/exchange:1.0.0 ./exchange
docker build -t bank/exgen:1.0.0 ./exgen
docker build -t bank/front:1.0.0 ./front
docker build -t bank/gateway:1.0.0 ./gateway
docker build -t bank/notify:1.0.0 ./notify
docker build -t bank/transfer:1.0.0 ./transfer
затем стартовать весь проект с помощью docker-compose 
docker-compose -f docker-compose-test.yml up





памятка по портам
accounts    8082
auth        9000
blocker     8087
cash        8085
config      8888
eureka      8761
exchange    8083
exgen       8084
front       8081
gateway     8080
notify      8088
transfer    8086




недоделки

- не сделал Hysterix ( ретраи запросов и фолбеки сделаны логикой где надо )
- нет тестов


ревью

- ты в репозиторий закоммитил файлы базы (*.db, *.lock.db). Мы обычно на проекте так не делаем, добавь их  в .gitignore`.
- В cash и transfer контроллерах ты вручную прокидываешь токен из запроса в следующий вызов. Это будет повторяться везде. 
Лучше настрой RestTemplate с ClientHttpRequestInterceptor, который будет автоматом Authorization копировать.
- И вот это DB_PATH:~/IdeaProjects/javamid-bank/data в конфиге, так не надо, путь должен быть относительным 
или полностью управляться через переменные окружения в Docker.
- Ну и пиши тесты :)
Александр Передерей
ревьюер



